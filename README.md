codeiq-crossing
===============

Solutions to CodeIQ Challenge 432 "Crossing"

結城浩さんによるCodeIQの出題、「クロッシング問題」のCによる解答例です。
 * [交差点をすばやく数えよう！](https://codeiq.jp/ace/yuki_hiroshi/q432)

終了した問題は見られなくなってしまうのですね。残念です。

今回、Cを使って5通りの解を作りました。
 1. [naive.c](naive.c)
   * 普通に転倒数を数えます。O(n^2)。私のマシンでは63秒くらいです。
 2. [bitcount.c](bitcount.c)
   * 出力点を左から順にスキャンしつつ、すでに出現した数をビットマップに保持します。現在注目して数より大きいものの出現数を数えると、この位置での転倒数に等しくなります。ビットマップ中、注目数に対応する位置より右側にある1の立っているビットの数を数えます。ワード中の1の立っているビットを数えるにはGCCの__builtin_popcountll()を使いました。
   * popcountを数える計算がnに比例するので、実はO(n^2)です。0.7秒(700ms)くらいです。
 3. [mergecount.c](mergecount.c)
   * マージソートしながら数えます。[Stack Overflowの記事](http://stackoverflow.com/a/6424847)にあるJavaプログラムをCで書き直したものです。
   * ポイントは、マージで右側のランから要素を取るとき、左側のランの残り数だけ飛び越えるので、この分が転倒数になる点です。
   * O(n log n)、100msくらいです。
 4. [mergecount2.c](mergecount2.c)
   * 同様ですが、入力ファイルを読み込みながら、すでにソート済の部分列(ラン)を特定していきます。
   * crossing.txtには157206個のランがありました。結城さん、絶妙な問題を出しますねえ。最長のランは8でした。
   * O(n log n)、80msくらいです。
 5. [treecount.c](treecount.c)
   * 解2のbitcount.cと同様、すでに出現した数のうち、注目している数より大きいものを数えますが、ここをlog nになるようにしたものです。
   * 下図(左)のようなツリーを考え、各ノードには光線の出力位置番号を対応させます。このノードに自分も含め、右側のサブツリー以下にあるすでに出現した数の個数合計を記録します。
   * 例えば 3, 6, 7が出現しているとき、ツリーは下図(右)のようになります。ここで5が入ったきた場合、5→6→4とツリーを上にたどりながら、ノード番号が自分以上のものの保持する個数を合計すれば、それが5より大きな数の個数になります。
   * O(log n)で数えることをn回実行するので、O(n log n)となります。88msくらいでした。
<pre>
      4                2 
    /   \            /   \   
   2     6          1     2
  / \   / \        / \   / \ 
 1   3 5   7      0   1 0   1
</pre>
